import 'dart:convert';

import 'package:flutter/material.dart';
// Importing http package 'as http' will avoid name clashes. All properties/methods of http class will be accessed with http.COMMAND.
import 'package:http/http.dart' as http;

import '../mocks/mock_inventory.dart';
import '../models/http_exception.dart';
import '../widgets/my_snack_bar.dart';
import 'product_item.dart';

class Products with ChangeNotifier {
  // List<ProductItem> _products = MOCK_INVENTORY;
  List<ProductItem> _products = [];

  List<ProductItem> get allProducts {
    return [..._products];
  }

  List<ProductItem> get favouriteProducts {
    return _products.where((indexProduct) => indexProduct.isFavourite).toList();
  }

  Future<void> fetchAllProducts() async {
    final url = Uri.parse('https://shop-8727a-default-rtdb.firebaseio.com/products.json');

    try {
      // This will return a JSON map. {key: productItemId {key: value...}}.
      final response = await http.get(url);

      // The data from http.get() is actually a Map of ID keys, with each ID key having a nested map of product properties. Here, the nested Map data will be inferred to be a Map (since dynamic doesn't set a type).
      Map<String, dynamic> extractedData = json.decode(response.body);
      // final extractedData = json.decode(response.body) as Map<String, dynamic>;

      final List<ProductItem> loadedProducts = [];

      extractedData.forEach((productId, productData) {
        loadedProducts.add(ProductItem(
          productItemId: productId,
          title: productData['title'],
          description: productData['description'],
          price: productData['price'],
          imageUrl: productData['image_url'],
          isFavourite: productData['is_favourite'],
        ));
      });
      _products = loadedProducts;
      notifyListeners();
    } catch (error) {
      print('ERROR FETCHING ALL PRODUCTS');
      print('ERROR: $error');
    }
  }

  ProductItem findProductById(String productItemId) {
    return _products.firstWhere((product) => product.productItemId == productItemId);
  }

  // Futures can be handled more elegantly with async functions. Adding the async keyword turns the function into a Future. Also means you can get rid of .then() and .catchError(). See below.
  // // Future<void> addProduct(ProductItem product) {
  Future<void> addProduct(ProductItem product) async {
    // The Future function has to return something other than null (see below).

    // Store new product locally and send a snapshot to the Realtime Database.
    // The app by default does not wait for http requests to complete. But we can make the app wait programaticlly with Futures and async code.
    // http accesses the database URL through a URI object endpoint. The endpoint URL can be copied from the Realtime Database and we can add /products.json to create a collection in that database. Firebase requires .json to know to parse your request into named arguments from the JSON format (JavaScript Object Notation).
    // Send post request with a body: containing JSON map. dartconvert package gives us json.encode() to create a JSON map from the product object passed to the addProduct method.
    // http.post() returns a Future, so we can use .then() which returns a Response object and executes a function when the http.post() is complete. Ideally, we want to wait for the http.post() to finish so we can use the same productItemId auto-generated by the Realtime Database. Conveniently, the Response object from http.post() contains a JSON body: that includes the 'name': of the auto-generated id, or Key.
    // Dart actually registers Future functions as to-dos and continues to execute code. You can daisy-chain .catchError(() {}) and .then(() {}) b/c they themselves are Future functions by default! So...have the function return the http.post() since it is a Future.
    final url = Uri.parse('https://shop-8727a-default-rtdb.firebaseio.com/products.json');

    // Await allows for synchronous syntax operating as asynchronous .then() functions. The response or error now needs to be assigned to a variable.
    // Put code that might fail at run-time (eg, user input, internet connection, server status) AND the code that should run if there isn't an error inside a try{} block (see below).
    try {
      final response = await http.post(
        url,
        body: json.encode(
          {
            'title': product.title,
            'description': product.description,
            'price': product.price,
            'image_url': product.imageUrl,
            'is_favourite': product.isFavourite,
          },
        ),
      );
      final newProduct = ProductItem(
        productItemId: response.body,
        title: product.title,
        description: product.description,
        price: product.price,
        imageUrl: product.imageUrl,
        isFavourite: false,
      );
      _products.add(newProduct);
      notifyListeners();
    } catch (error) {
      print('http.post() or .then() threw the following error: $error');
      // Throw error so the widget can get error method and update UI accordingly.
      throw (error);
    }

    // // // .then((response) {
    // // final newProduct = ProductItem(
    // //   productItemId: response.body,
    // //   title: product.title,
    // //   description: product.description,
    // //   price: product.price,
    // //   imageUrl: product.imageUrl,
    // //   isFavourite: false,
    // // );
    // // // _products.add(newProduct);
    // // _products.insert(0, newProduct);
    // // notifyListeners();
    // // // )},

    // If you put .catchError before .then(), .then() will still run after .catchError(). The .then() method will be skipped if error is thrown in http.post(). But if the error is in .then(), all non-erroneous code will still execute. However, with async function, you can now use a try {} block to catch errors
    // // .catchError((error) {
    // // print('http.post() or .then() threw the following error: $error');
    // // throw error;
    // // });

    // If you put return outside the Future http request block, Dart will register the "to-do" functions, continue executing code, and return immediately.
    // // return Future.value();
  }

  Future<void> updateProduct(String editProductId, ProductItem editProduct) async {
    final productIndex = _products.indexWhere((product) => product.productItemId == editProductId);
    if (productIndex >= 0) {
      final url = Uri.parse('https://shop-8727a-default-rtdb.firebaseio.com/products/$editProductId.json');
      // CAN IMPLEMENT TRY-CATCH-FINALLY FOR ERROR HANDLING HERE AS ABOVE
      await http.patch(
        url,
        body: json.encode({
          'title': editProduct.title,
          'description': editProduct.description,
          'price': editProduct.price,
          'image_url': editProduct.imageUrl,
        }),
      );
      _products[productIndex] = editProduct;
      notifyListeners();
    }
  }

  // You can implement 'optimistic updating' where async/await are not required. (We will use async for error handling).
  Future<void> deleteProduct(String delProductId) async {
    final url = Uri.parse('https://shop-8727a-default-rtdb.firebaseio.com/products/$delProductId.json');

    // Normally Dart would remove a deleted item from memory if nothing else int he code is 'interested' in it. This keeps the existing product in memory. However, it is still removed from the master _products list below. Useful to undo delete if there is an error updating the database (or if the user decides to undo the delete).
    var existingProductIndex = _products.indexWhere((product) => product.productItemId == delProductId);
    // Shouldn't be final because we are going to dispose() it below.
    var existingProduct = _products[existingProductIndex];

    // This is the overall structure of the tutorial code block below.
    // // http.delete(url).then((response) {}).catchError((error) {});

    // The Future API and callbacks
    // Functions that use the Future API register callbacks that handle the value (or the error) that completes a Future. For example:

    // myFunc().then(processValue).catchError(handleError);
    // The registered callbacks fire based on the following rules: then()’s callback fires if it is invoked on a Future that completes with a value; catchError()’s callback fires if it is invoked on a Future that completes with an error.

    // In the example above, if myFunc()’s Future completes with a value, then()’s callback fires. If no new error is produced within then(), catchError()’s callback does not fire. On the other hand, if myFunc() completes with an error, then()’s callback does not fire, and catchError()’s callback does.`

    // Have to be careful with how to handle http.delete().

    // If the server URL is incorrect (ie, the API/server can't be reached), it will throw an error, skip .then() block, and execute .catchError() block.
    // If the server URL is correct (ie, the API/server can be reached), but there is an error in the rest of the address, it will return a response (with an int statusCode >= 400), execute .then(), skip .catchError() and exit the http.delete() block. In this case, you have to manually 'throw' an Error or Exception (not a Response) in .then() to execute the .catchError() block.

    // Instead of .removeWhere() and find the matching productItemId, we can use .removeAt() since we found the index above.
    // // _products.removeWhere((product) => product.productItemId == delProductId);
    _products.removeAt(existingProductIndex);
    notifyListeners();

    // Try-Await-Catch-Finally is the best way to handle errors. This code is only for demonstration purposes. Interestingly, this code below will not catch a major error such as an invalid API address. But the .then().catchError() code dispose() the existingProduct before Dart tries to use it in the async code!

    final response = await http.delete(url);
    if (response.statusCode >= 400) {
      _products.insert(existingProductIndex, existingProduct);
      notifyListeners();
      throw HttpException('Could not delete product');
    }
    existingProduct.dispose();

    // http.delete(url).then((response) {
    //   // http.delete(url) does not throw an error if status code >= 400. We have to manually throw an error (or Exception) from the .then() block.
    //   if (response.statusCode >= 400) {
    //     // Dart has its own Exception class, but recommends you build your own for more granular control over error handling/messages.
    //     // HttpException expects a String. In this case we'll give it one, but we'll never use it. We're more interesting in throwing an Exception to get us in the .catchError() block since http.delete doesn't throw an error for >= 400.
    //     throw HttpException('Could not delete product');
    //   }
    // }).catchError((_) {
    //   // If there was an error removing the item from the database, reinstert the item at the index stored above.
    //   _products.insert(existingProductIndex, existingProduct);
    //   notifyListeners();
    // });
  }
}
